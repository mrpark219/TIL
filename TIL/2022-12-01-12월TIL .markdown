---
layout: post
title: "2022년 12월 TIL"
date: 2022-12-01 23:35:00 +0900
categories: 202212 TIL
---

---

### 12/1(목)

오브젝트 - 부록B. 타입 계층의 구현  
[p.576 ~ p.582]

-   타입 계층을 구현할 수 있는 다양한 방법:

    2. 인터페이스를 이용한 타입 계층 구현:  
       대부분의 언어는 다중 상속을 지원하지 않는다. 그리고 상속 계층을 통해 타입을 구현하면 자식 클래스가 부모 클래스와 클래스의 구현에 강하게 결합될 확률이 높다. 따라서 상속 계층 안의 클래스 하나를 변경했는데도 수많은 자식 클래스들이 영향을 받을 수 있다. 상속으로 인한 결합도 문제를 피하고 다중 상속이라는 구현 제약도 해결할 수 있는 방법은 클래스가 아닌 인터페이스를 사용하여 타입 계층을 구현하는 것이다.  
       한 타입은 좀 더 많은 행동을 가진 다른 타입에 의해 확장될 수 있다. 이때 인터페이스가 다른 인터페이스를 확장하도록 만들면 슈퍼타입과 서브타입 간의 타입 계층을 구성할 수 있다.  
       인터페이스를 통해 타입을 정의하면 클래스를 통해 해당 타입에 속하는 객체들을 구현할 수 있다. 자바와 C#에서는 인터페이스를 이용해 타입의 퍼블릭 인터페이스를 정의하고 클래스를 이용해 객체를 구현하는 것이 일반적인 패턴이다. 인터페이스와 클래스를 함께 조합하면 다중 상속의 딜레마에 빠지지 않을 수 있고 단일 상속 계층으로 인한 결합도 문제를 피할 수 있다. 아래는 타입과 타입을 구현한 클래스 사이의 관계의 특징이다.

        - 여러 클래스가 동일한 타입을 구현할 수 있다:  
          한 인터페이스를 구현하는 여러 클래스들은 서로 다른 방법으로 구현할 수 있지만 동일한 타입을 가진다.
        - 하나의 클래스가 여러 타입을 구현할 수 있다:  
          한 클래스가 여러 개의 인터페이스를 구현할 수 있다.

        타입은 동일한 퍼블릭 인터페이스를 가진 객체들의 범주이고, 클래스는 타입에 속하는 객체들을 구현하기 위한 구현 메커니즘이다.

---

### 12/2(금)

오브젝트 - 부록B. 타입 계층의 구현  
[p.582 ~ p.584]

-   타입 계층을 구현할 수 있는 다양한 방법:

    3. 추상 클래스를 이용한 타입 계층 구현:  
       추상 클래스를 이용하면 클래스 상속을 이용해 구현을 공유하면서도 결합도로 인한 부작용을 피할 수 있다. 구체 클래스로 타입을 정의해서 상속받는 방법과 추상 클래스로 타입을 정의해서 상속받는 방법 사이에는 아래의 두 가지 중요한 차이점이 있다.

        - 의존하는 대상의 추상화 정도가 다르다:  
          클래스를 이용해 타입 계층을 구현한 경우 자식 클래스의 메서드가 부모 클래스의 메서드의 구체적인 내부 구현에 강하게 결합된다. 반면 추상 클래스의 경우 자식 클래스가 부모 클래스의 내부 구현이 아닌 추상 메서드의 시그니처에만 의존한다.
        - 상속을 사용하는 의도가 다르다:  
          클래스를 이용해 타입 계층을 구현하는 경우 상속을 염두로 두고 설계된 것이 아니다. 따라서 클래스에는 미래의 확장을 위한 어떤 준비도 돼 있지 않다. 반면 추상 클래스의 경우 처음부터 상속을 염두에 두고 설계된 클래스다. 추상 클래스는 자신의 인스턴스를 직접 생성할 수 없다. 추상 클래스는 추상 메서드를 제공함으로써 상속 계층을 쉽게 확장할 수 있게 하고 결합도로 인한 부작용을 방지할 수 있는 안전망을 제공한다.

    모든 구체 클래스의 부모 클래스를 항상 추상 클래스로 만들기 위해 노력해야 한다. 의존하려는 대상이 더 추상적일수록 결합도는 낮아지고 결합도가 낮아질수록 변경으로 인한 영향도는 줄어든다.

---

### 12/3(토)

오브젝트 - 부록B. 타입 계층의 구현  
[p.585 ~ p.588]

-   대부분의 객체지향 언어들은 하나의 부모 클래스만 가질 수 있도록 허용하는 단일 상속만 지원한다. 이 경우 여러 타입으로 분류되는 타입이 문제가 될 수 있다. 이런 경우에는 타입 계층을 오묘한 방식으로 비틀어서 해결할 수 있다.  
    자바와 C#에서 제공하는 인터페이스를 이용해 타입을 정의하면 다중 상속 문제를 해결할 수 있다. 클래스가 구현할 수 있는 인터페이스의 수에는 제한이 없기 때문에 하나의 클래스가 하나 이상의 타입으로 분류 가능하도록 손쉽게 확장할 수 있다.  
    그러나 인터페이스만을 사용하는 방법에도 단점이 있다. 자바8 이전 버전이나 C#에서 제공하는 인터페이스에는 구현 코드를 포함시킬 수 없기 때문에 인터페이스만으로는 중복 코드를 제거하기 힘들다. 따라서 효과적인 접근 방법은 인터페이스를 이용해 타입을 정의하고 특정 상속 계층에 국한된 코드를 공유할 필요가 있을 경우에는 추상 클래스를 이용해 코드 중복을 방지하는 것이다. 이런 형태로 추상 클래스를 사용하는 방식을 **골격 구현 추상 클래스(skeletal implementation abstract class)** 라고 부른다.  
    인터페이스와 추상 클래스를 함께 사용하는 방법은 추상 클래스만을 사용하는 방법에 비해 아래 두 가지 장점을 가진다.

    -   다양한 구현 방법이 필요한 경우 새로운 추상 클래스를 추가해서 쉽게 해결할 수 있다.
    -   이미 부모 클래스가 존재하는 클래스라고 하더라도 인터페이스를 추가함으로써 새로운 타입으로 쉽게 확장할 수 있다.

    설계에 상속 계층이 얽매이지 않는 타입 계층이 요구된다면 인터페이스로 타입을 정의하는 것이 좋다. 또한, 추상 클래스로 기본 구현을 제공해서 중복 코드르 제거하는 것이 좋다. 하지만 이런 복잡성이 필요하지 않다면 타입을 정의하기 위해 인터페이스나 추상 클래스 둘 중 하나만 사용하는 것이 좋다. 타입의 구현 방법이 단 한가지이거나 단일 상속 계층만으로도 타입 계층을 구현하는 데 무리가 없다면 클래스나 추상 클래스를 이용해 타입을 정의하는 것이 좋다. 그 외의 상황에는 인터페이스를 이용하는 것을 고려하는 것이 좋다.

---

### 12/4(일)

오브젝트 - 부록B. 타입 계층의 구현  
[p.588 ~ p.595]

-   덕 타이핑은 주로 동적 타입 언어에서 사용하는 방법으로서 **덕 테스트(duck test)** 를 프로그래밍 언어에 적용한 것이다. 덕 테스트는 어떤 대상의 '행동'이 오리와 같다면 그것을 오리라는 타입으로 취급해도 무방하다는 것이다. 즉, 객체가 어떤 인터페이스에 정의된 행동을 수행할 수만 있다면 그 객체를 해당 타입으로 분류해도 문제가 없다.  
    자바 같은 대부분의 정적 타입 언어에서는 두 클래스를 동일한 타입으로 취급하기 위해서는 코드 상의 타입이 동일하게 선언돼 있어야만 한다. 단순히 동일한 시그니처의 메서드를 포함한다고 해서 같은 타입으로 판단하지 않는다. 즉, 정적 타입 언어에서는 객체의 퍼블릭 인터페이스만으로 타입을 추측하는 것이 불가능하며 모든 요소의 타입이 명시적으로 기술돼 있어야 한다.  
    반면 런타임에 타입을 결정하는 동적 타입 언어, 대표적으로 루비는 특정한 클래스를 상속받거나 인터페이스를 구현하지 않고도 객체가 수신할 수 있는 메시지의 집합으로 객체의 타입을 결정할 수 있다.  
    덕 타이핑은 타입이 행동에 대한 것이라는 사실을 강조한다. 두 객체가 동일하게 행동한다면 내부 구현이 어떤 방식이든 상관없다. 타입 관점에서 두 객체는 동일한 타입이다.  
    인터페이스가 클래스보다 더 유연한 설계를 가능하게 해주는 이유는 클래스가 정의하는 구현이라는 컨텍스트에 독립적인 코드를 작성할 수 있게 해주기 때문이다. 덕 타이핑은 여기서 한 걸음 더 나아간다. 단지 메서드의 시그니처만 동일하면 명시적인 타입 선언이라는 컨텍스트를 제거할 수 있다. 덕 타이핑은 클래스나 인터페이스에 대한 의존성을 메시지에 대한 의존성으로 대체한다. 따라서 코드는 낮은 결합도를 유지하고 변경에 유연하게 대응할 수 있다.  
    그러나 덕 타이핑을 사용하면 컴파일 시점에 발견할 수 있는 오류를 실행 시점으로 미루게 되기 때문에 설계의 유연성을 얻는 대신 코드의 안전성을 약화시킬 수 있다.

---

### 12/5(월)

오브젝트 - 부록B. 타입 계층의 구현  
[p.595 ~ p.597]

-   **믹스인(mixin)** 은 객체를 생성할 때 코드 일부를 섞어 넣을 수 있도록 만들어진 일종의 추상 클래스다. 언어마다 구현 방법에 차이는 있지만 믹스인을 사용하는 목적은 다양한 객체 구현 안에서 동일한 행동을 중복 코드 없이 재사용할 수 있게 만드는 것이다.  
    믹스인을 통해 코드를 재사용하는 객체들은 동일한 행동을 공유하게 된다. 즉, 공통의 행동이 믹스인된 객체들은 동일한 메시지를 수신할 수 있는 퍼블릭 인터페이스를 공유하게 된다. 타입은 퍼블릭 인터페이스와 관련이 있기 때문에 대부분의 믹스인을 구현하는 기법들은 타입을 정의하는 것으로 볼 수 있다. 믹스인은 간결한 인터페이스(thin interface)를 가진 클래스를 풍부한 인터페이스(rich interface)를 가진 클래스로 만들기 위해 사용될 수 있다.  
    자바 8에서는 새롭게 추가된 **디폴트 메서드(default method)** 를 통해 인터페이스에 메서드의 기본 구현을 추가하는 것을 허용한다. 이는 스칼라의 트레이트와 유사하다. 인터페이스에 디폴트 메서드가 구현돼 있다면 이 인터페이스를 구현하는 클래스는 기본 구현을 가지고 있는 메서드를 구현할 필요가 없다. 디폴트 메서드를 사용하면 추상 클래스가 제공하는 코드 재사용성이라는 혜택을 그대로 누르면서도 특정한 상속 계층에 얽매이지 않는 인터페이스의 장점을 유지할 수 있다.

---

#### 12/6(화)

오브젝트 - 부록B. 타입 계층의 구현  
[p.598 ~ p.600]

-   디플트 메서드가 제공하는 혜택을 누리면서 설계를 견고하기 유지하기 위해서는 디폴트 메서드가 가지는 한계를 분명하게 인식하는 것이 중요하다. 디폴트 메서드에서 내부적으로 사용하는 메서드는 해당 인터페이스를 구현하는 모든 클래스에서 명시적으로 구현을 제공해야 한다는 것을 의미한다. 이때 문제는 이 메서드들이 인터페이스에 정의돼 있기 때문에 클래스 안에서 퍼블릭 메서드로 구현돼야 한다는 것이다. 이는 외부에 노출할 필요가 없는 메서드를 불필요하게 퍼블릭 인터페이스에 추가하는 결과를 낳는다. 따라서 캡슐화를 약화시킨다.  
    자바 8에서 디폴트 메서드를 추가한 이유는 인터페이스로 추상 클래스의 역할을 대체하려는 것이 아니다. 디폴트 메서드가 추가된 이유는 기존에 널리 사용되고 있는 인터페이스에 새로운 오퍼레이션을 추가할 경우에 발생하는 하위 호환성 문제를 해결하기 위해서지 추상 클래스를 제거하기 위한 것이 아니다.
-   인터페이스에 새로운 메서드를 추가하는 등 인터페이스를 바꾸고 싶을 떄 문제가 발생한다. 인터페이스를 바꾸면 기존에 해당 인터페이스를 구현했던 모든 클래스의 구현도 고쳐야 하기 때문이다. 따라서 자바 8에서는 기본 구현을 포함하는 인터페이스를 정의하는 두 가지 방법을 제공한다. 첫 번째는 인터페이스 내부에 정적 메서드를 사용하는 것이고, 두 번째는 인터페이스의 기본 구현을 제공할 수 있게 디폴트 메서드라는 기능을 사용하는 것이다. 즉 자바 8에서는 메서드 구현을 포함하는 인터페이스를 정의할 수 있다. 결과적으로 기존 인터페이스를 구현하는 클래스는 자동으로 인터페이스에 추가된 새로운 메서드의 디폴트 메서드를 상속받게 된다.[Urma14]

---

### 12/7(수)

오브젝트 - 부록C. 동적인 협력, 정적인 코드  
[p.601 ~ p.602]

-   협력을 구성하기 위해서는 살아 움직이는 객체가 필요하다. 객체는 태어나고, 협력하고, 책임을 다하고 나면 소멸한다. 객체의 상태는 지속적으로 변하고, 외부의 자극에 따라 다양한 방식으로 행동한다. 즉 객체는 동적이다.  
    개발자는 객체의 움직임과 변화를 표현하기 위해 객체지향 언어를 사용한다. 이때 객체는 동적이지만 프로그래밍을 위해 사용하는 텍스트라는 표현 도구는 정적이라는 문제가 발생한다. 그렇기 때문에 프로그래머가 객체지향 프로그램을 작성하기 위해서는 두 가지 모델을 동시에 마음속에 그려야 한다. 하나는 프로그램 실행 구조를 표현하는 움직이는 모델이고, 또 다른 하나는 코드의 구조를 담는 고정된 모델이다. 전자를 **동적 모델(dynamic model)** 이라고 부르고 후자를 **정적 모델(static model)** 이라고 부른다.
-   객체지향의 세계에서 동적 모델은 **객체** 와 **협력** 으로 구성된다. 객체는 다른 객체와 협력하면서 애플리케이션의 기능을 수행한다. 객체지향의 세계에서 정적인 모델은 **타입** 과 **관계** 로 구성된다. 타입은 객체를 분류하기 위한 틀로서 동일한 타입에 속하는 객체들이 수행할 수 있는 모든 행동들을 압축해서 표현한 것이다.
-   위에서 살펴본 동적 모델과 정적 모델이 있을 때 동적 모델을 우선해야 한다. 정적 모델은 동적 모델에 의해 주도돼야 하고 동적 모델이라는 토대 위에 세워져야 한다. 프로그램 코드 안에 담아지는 정적 모델은 객체 사이의 협력에 기반해야 한다.  
    동적 모델을 기반으로 정적 모델을 구상할 때 고려해야 하는 중요한 요소는 **변경**이다. 설계가 필요한 이유는 변경을 수용할 수 있는 코드를 만들기 위해서다. 변경을 수용할 수 있는 코드는 **단순하고, 결합도가 낮으며, 중복 코드가 없는 코드** 를 말한다.
    -   수정이 용이한 코드란 응집도가 높고, 결합도가 낮으며, 단순해서 쉽게 이해할 수 있는 코드다.
    -   유연한 코드란 동일한 코드를 이용해 다양한 컨텍스트에서 동작 가능한 협력을 만들 수 있는 코드다. 유연성의 관점에서 작성된 코드는 객체 사이의 다양한 조합을 지원해야 한다.

---

### 12/8(목)

오브젝트 - 부록C. 동적인 협력, 정적인 코드  
[p.603 ~ p.604]

-   협력에 참여하는 객체의 행동이 객체의 정적 모델을 결정해야 한다. 객체의 정적 모델은 동적 모델이라는 토대 없이는 완전해질 수 없다. 가장 중요한 것은 객체가 외부에 제공하는 행동이다. 정적 모델을 선택하는 이유는 단지 행동과 변경을 적절하게 수용할 수 있는 코드 구조를 찾는 것이어야 한다.  
    정적 모델을 미리 결정하고 객체의 행동을 정적 모델에 맞춰서는 안된다. 동적 모델이 정적 모델을 결정해야 한다. 만약 정적 모델이 협려에 적합하지 않다면 정적 모델을 지속적으로 개선해야 한다.

---

### 12/9(금)

오브젝트 - 부록C. 동적인 협력, 정적인 코드  
[p.604 ~ p.607]

-   **도메인(domain)** 이란 사용자가 프로그램을 사용하는 대상 영역을 가리킨다. **모델(model)** 이란 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.[Evans03] **도메인 모델(domain model)** 이란 사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순하고 의식적으로 구조화한 형태다. 도메인 모델은 소프트웨어를 만드는 데 필요한 개념의 이름과 의미 그리고 관계에 대한 힌트를 제공하는 역할로 끝나야 한다.  
    코드의 구조를 이끄는 것은 도메인 안에 정립된 개념의 분류 체계가 아니라 객체들의 협력이다. 도메인 안의 개념들을 기반으로 출발하되 객체들의 협력이 도메인 모델에 맞지 않다면 필요한 몇 가지 개념만 남기고 도메인 모델을 과감히 수정하는 것이 좋다.

---

### 12/10(토)

오브젝트 - 부록C. 동적인 협력, 정적인 코드  
[p.607 ~ p.611]

-   도메인 모델을 기반으로 코드를 작성하면 원하는 협력을 지원할 수 있기 때문에 도메인 모델을 작성하는 것은 소프트웨어를 만드는 출발점이다.
-   타입을 구현할 수 있는 다른 방법이 있다. 인터페이스나 클래스로 구현하는 것이 아니라 타입을 표현하는 클래스의 인스턴스로 구현된다. 즉, 어떤 객체의 타입을 표현하는 별도의 객체를 이용해 타입을 구현하는 것이다.  
    이처럼 어떤 인스턴스가 다른 인스턴스의 타입을 표현하는 방식을 **TYPE OBJECT 패턴** 이라고 부른다.[Johnson97b, Nystrom14]
