---
layout: post
title: "2022년 8월 TIL"
date: 2022-08-01 00:05:00 +0900
categories: 202208 TIL
---

### 8/1(월)

객체지향의 사실과 오해 - 부록A. 추상화 기법  
분류와 인스턴스화

[개념과 범주]  
객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 **개념**을 적용하는 것을 의미한다. 개념이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다.  
세상에 존재하는 객체에 개념을 적용하는 과정을 **분류**라고 한다. 분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다.  
사람들은 분류를 통해 개별 현상을 하나의 개념으로 다룬다. 분류는 객체를 타입과 연관시키는 것이다. 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 **인스턴스화** 또는 **예시**라고 한다.

객체지향에서 개념을 가리키는 표준 용어는 **타입**이다. 타입은 개념과 동의어이다. 분류란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하므로 객체를 타입의 **인스턴스**라고 한다.

분류는 객체와 타입 간의 관계를 나타낸 것이다. 어떤 객체가 타입의 정의에 부합할 경우 그 객체는 해당 타입으로 분류되며 자동으로 타입의 인스턴스가 된다.

[타입]  
객체를 타입에 따라 분류하기 위해서는 객체가 타입에 속하는지 여부를 확인할 수 있어야 한다. 특정 객체를 어떤 타입이라고 말할 수 있으려면 타입에 대한 명확한 정의가 필요하다. 타입에 대한 명확한 정의가 내려진 후에 어떤 객체가 타입의 인스턴스인지 여부를 쉽게 판단할 수 있다.  
타입을 객체의 분류 장치로서 적용하려면 아래 세 가지 관점에서의 정의가 필요하다.

-   **심볼**: 타입을 가리키는 간략한 이름이나 명칭
-   **내연**: 타입의 오나전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
-   **외연**: 타입에 속하는 모든 객체들의 집합

도메인을 분석하는 동안 이름, 의미, 객체들의 집합을 이용해 개념을 정의할 수 있다.

[외연과 집합]  
타입의 외연은 타입에 속하는 객체들의 집합으로 표현한다. 집합은 외연을 가리키는 또 다른 명칭이다. 객체들은 동시에 서로 다른 집합에 포함될 수도 있다.  
사람들은 한 시점에 동일한 객체를 다양한 방식으로 인지하기 때문에 이것은 사람들이 세상을 인지하는 일반적인 방식을 반영한다.  
한 객체가 한 시점에 하나의 타입에만 속하는 것을 **단일 분류(single classification)**라고 한다. 반면 한 객체가 한 시점에 여러 타입에 속할 경우 이를 **다중 분류(multiple classification)**라고 한다.

대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다. 대부분의 언어에서 한 객체는 오직 한 클래스의 인스턴스여야만 하며 동시에 두 개의 클래스의 인스턴스일 수는 없다. 이는 다중 상속과는 다른 것으로, 다중 상속은 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용하지만 타입 정의를 생략할 수는 없다. 반면 다중 분류는 특정한 타입을 정의하지 않고도 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 허용한다.

객체를 특정한 타입으로 분류하면 해당 객체는 타입의 집합에 포함된다. 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우를 **동적 분류(dynamic classification)**라고 한다. 반면 객체가 자신의 타입을 변경할 수 없는 경우를 **정적 분류(static classification)**라고 한다.

다중 분류와 동적 분류는 서로 베타적인 개념이 아니다. 다중 분류와 동적 분류를 함께 적용하는 것이 실세계의 복잡성을 모델링하는 데 유용하다. 대부분의 언어는 일반 클래스로부터 인스턴스를 생성한 후 클래스를 변경하는 방법을 제공하지 않는다. 즉, 객체의 타입을 변경할 수 없다. 따라서 대부분의 언어는 정적 분류만 허용하며 동적 분류를 구현할 수 있는 방법을 제공하지 않는다.

다중 분류와 동적 분류는 개념적인 관점에서 도메인을 분석하는 데 유용하지만 객체지향 프로그래밍 언어로 구현하는 것이 쉽지 않다. 그렇기 때문에 다중 분류와 정적 분류 방식으로 객체들의 범주를 재조정하는 편이 분석과 구현 간의 차이를 메울 수 있는 가장 현실적인 방법이다.

[클래스]  
객체지향 프로그래밍 언어를 이용해 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다. '타입을 구현한다'라고 표현한 이유는 클래스와 타입이 동일한 개념이 아니기 때문이다. 클래스는 타입을 구현하는 용도 외에도 코드를 재사용하는 용도로 사용되기도 한다. 클래스 외에도 인스턴스를 생성할 수 없는 추상 클래스나 인터페이스를 통해 타입을 구현할 수도 있다.

객체들이 동일한 특성을 가진다면 그것들은 동일한 카테고리에 속한다. 따라서 객체들의 카테고리는 객체들이 공유하는 공통적인 특성에 의해 정의된다. 또한, 객체의 특성을 본질적인 속성과 유연적인 속성으로 분류할 수 있다. 본질(essence)이란 한 사물의 가장 핵심적이고 필수불가결한 속성이다. 본질적이지 않은 속성을 우연적(accidental) 속성이라고 한다.

클래스는 객체가 공유하는 본질적인 속성을 정의한다. 대부분의 객체지향 프로그래밍 언어에서 동일한 범주에 속하는 객체는 동일한 클래스의 인스턴스여야 한다. 대부분의 객체지향 언어는 본질적인 속성을 표현할 수 있지만 우연적인 속성은 표현할 수 없다. 따라서 동일한 범주에 속하는 객체는 모두 동일한 속성을 가져야 한다.

자바스크립트처럼 클래스가 존재하지 않는 프로토타입 기반의 언어에서 분류와 인스턴스화는 프로토타입이라는 객체의 복사를 통해 이뤄진다.

---

### 8/2(화)

객체지향의 사실과 오해 - 부록A. 추상화 기법  
일반화와 특수화

[범주의 계층]  
1735년 카를로스 린네는 생문 분류법에 대한 논문인 「자연의 체계」를 발표한다. 이는 '계'라는 최상위 단계가 있는 중첩된 계층 구조였다. 이는 다시 문, 강, 목, 과, 속, 종으로 세분화됐으며 각 단계를 가리키는 라틴어 명칭이 존재했다.  
린네의 계층 구조는 좀 더 세부적인 범주가 계층의 하위에 위치하고 좀 더 일반적인 범주가 계층의 상위에 위치한다. 이떄 게층의 상위에 위치한 범주를 계층의 하위에 위치한 범주의 **일반화**라고 하고, 계층의 하위에 위치한 범주는 계층의 상위에 위치한 범주의 **특수화**라고 한다.

[서브타입]  
객체지향에서는 범주는 개념을 의미하고, 개념은 타입을 의미함으로 일반호와 특수화는 계층 구조 안에 존재하는 타입 간의 관계를 의미한다. 어떤 타입이 다른 타입보다 일반적이라면 이 타입을 **슈퍼타입(supertype)**이라고 한다. 어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 **서브 타입(subtype)**이라고 한다. 슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화이다.

일반화와 특수화의 계층 구조에서 서브타입은 슈퍼타입이 가진 본질적인 속성과 함께 자신만의 추가적인 속성을 가진다. 이는 내연의 관점에서 슈퍼타입의 정의가 서브타입의 정의보다 더 일반적이라는 것을 의미한다.  
서브타입은 슈퍼타입의 본질적인 속성을 모두 포함하기 때문에 계층에 속하는 모든 서브타입들이 슈퍼타입의 속성을 공유한다는 것을 예상할 수 있다. 이를 통해 파편화된 사실을 모르더라도 복잡한 세상의 속성을 논리적으로 쉽게 이해할 수 있다.

크레이그 라만은 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 '100% 규칙'과 'Is-a 규칙'을 준수해야 한다고 말한다. 100% 규칙은 슈퍼타입의 정의가 100% 서브타입에 적용되야 하며 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치하는 것을 말한다. Is-a 규칙은 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함되어야 한다는 것이다. 대게 영어로 서브타입은 슈퍼타입이다(subtype is a supertype)라는 구문을 만듦으로써 테스트할 수 있다.  
흔히 일반화 관계를 **is-a 관계**라고 말한다. is-a 관계의 본질은 서브타입이 슈퍼타입의 부분집합이라는 것이다.

[상속]  
프로그래밍 언어를 이용해 일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간의 상속을 사용하는 것이다. 그러나 프로그램 내의 두 클래스 간의 상속 관계가 존재할 때 이 관계를 반드시 일반화 관계라고 할 수는 없다.

일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응(conformance)해야 한다는 것이다. 순응에는 구조적인 순응(structural conformance)과 행위적인 순응(behavioral conformance)의 두 가지 종류가 있다. 두 가지 모두 특정 기대 집합에 대해 서브타입의 슈퍼타입에 대한 **대체 가능성**을 의미한다. 구조적인 순응은 기대 집합은 속성과 연관관계에 대한 것이며 행위적인 순응은 기대 집합은 행위가 동일한 계약을 기반으로 하느냐에 관한 것이다.

구조적인 순응은 타입의 내연과 관련된 100% 규칙을 의미한다. 즉 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다. 따라서 서브타입이 슈퍼타입을 대체하더라도 구조에 관한 동일한 기대 집합을 만족시킬 수 있다.

행위적인 순응은 타입의 행위에 관한 것이며, 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다. 이를 **리스코프 치환 원칙(Liskov Substitution Principle)**이라고 한다.

상속의 또 다른 용도는 코드 중복을 제거하고, 공통 코드를 재사용하기 위한 언어적 메커니즘을 제공하는 것이다. 상속은 **서브타이핑(subtyping)**과 **서브클래싱(subclassing)**의 두가지 용도로 사용될 수 있다. 서브클래스가 슈퍼클래스를 대체할 수 있는 경우를 서브타이핑이라고 한다. 서브클래스가 슈퍼클래스를 대체할 수 없는 경우는 서브클래싱이라고 한다. 서브타이핑을 **인터페이스 상속(interface inheritance)**이라고 하고, 서브클래싱을 **구현 상속(implementation inheritance)**이라고 한다.

일반화를 위한 서브타이핑은 특정 기대 집합에 대한 서브타입과 슈퍼타입 간의 구조적, 또는 행위적 순응 관계를 의미하며, 대체 가능성을 내포한다. 상속은 서브타이핑을 프로그래밍 언어적으로 구현할 떄 사용하지만, 모든 상속이 서브타이핑인 것은 아니다. 서브클래스가 슈퍼클래스를 대체할 수 없고 단지 코드만 공유하고 있다면 서브타이핑이 아니라 서브클래싱이라고 한다.

여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 **위임(delegation)**을 사용하는 것이다. 어떤 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 부모 클래스로 위임한다. 부모 클래스에서도 메시지를 이해할 수 없다면 자신의 부모 클래스로 다시 메시지를 위임한다. 이는 계층 내의 어떤 클래스가 메시지를 처리하거나 최상위 부모 클래스에 위임도리 떄까지 반복된다.

클래스가 없는 프로토타입 언어에서 상속은 객체와 객체 간의 관계로 이뤄진다. 즉, 어떤 타입의 객체를 특정 객체 타입의 특수화로 만들거나 행동을 공유할 수 있게 만들고 싶은 경우 객체와 객체를 상속 관계를 통해 연결한다. 클래스 기반 언어와 프로토타입 기반 언어 모두 메시지는 위임 메커니즘에 의해 처리된다. 차이점은 자식 클래스와 부모 클래스 사이가 아니라 자식 객체와 부모 객체 사이에 위임이 이뤄진다는 것이다.

---

### 8/3(수)

객체지향의 사실과 오해 - 부록A. 추상화 기법  
집합과 분해

[계층적인 복잡성]

-   복잡성은 '계층'의 형태를 띤다.
-   단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 '안정적인 형태'의 수와 분포에 의존한다.

안정적인 형태의 부분으로부터 전체를 구축하는 행위를 **집합**이라고 하고 집합과 반대로 전체를 부분으로 분할하는 행위를 **분해**라고 한다. 집합은 불필요한 세부 사항을 추상화한다. 필요한 시점에는 전체를 분해함으로써 그 안에 포함된 부분들을 새로운 전체로 다룰 수 있다. 전체와 부분 간의 일관된 계층 구조는 재귀적인 설계를 가능하게 한다.

집합은 전체의 내부로 불필요한 세부 사항을 감춰주기 때문에 추상화 메커니즘인 동시에 캡슐화 메커니즘이다. 외부에서는 전체에 관해서만 알고 내부를 모르기 때문에 내부의 구성을 변경하더라도 외부에 영향을 미치지 않는다. 집합과 분배는 한 번에 다뤄야 하는 요소의 수를 감소시킴으로써 인지 과부하를 방지한다.

[합성 관계]  
객체와 객체 사이에 전체-부분 관계를 구현하기 위해서는 **합성 관계**를 사용한다. 합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다. 따라서 객체들의 그룹과 관련된 복잡성이 완화된다.  
단순한 물리적 통로가 존재하는 관계를 **연관 관계**라고 한다.

합성 관계와 연관 관계 사이의 차이가 항상 명확한 것은 아니지만 일반적으로 합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거된다. 반면 연관 관계로 연결된 두 객체는 생명주기와 관련된 어떤 제약도 부과하지 않는다. 연관 관계로 연결된 두 객체는 독립적으로 제거될 수 있다. 합성 관계는 생명주기 측면에서 연관 관계보다 더 강하게 객체들을 결합한다.

[패키지]  
소프트웨어의 구조를 단순화하기 위해서는 서로 연관성이 높은 클래스 집합을 논리적인 단위로 통합해야 한다. 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 **패키지(package)**또는 **모듈(module)**이라고 한다.  
패키지를 이용하면 시스템의 전체적인 구조를 이해하기 위해 한 번에 고려해야 하는 요소의 수를 줄일 수 있다. 또한 개별 클래스가 아닌 클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있다. 함께 협력하는 응집도 높은 클래스 집합을 하나의 패키지 내부로 모으면 코드를 이해하기 위해 패키지의 경계를 넘나들 필요가 적어진다.  
패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화한다.

---

### 8/4(목)

오브젝트 - 1. 객체, 설계
[p.7 ~ p.25]

-   소프트웨어 모듈이 가져야 하는 세 가지 기능:
    > 모든 소프트웨어 모듈에는 세 가지 목적이 있다. 첫 번쨰 목적은 실행 중에 제대로 동작하는 것이다. 이것은 모듈의 존재 이유할 수 있다. 두 번쨰 목적은 변경을 위해 존재하는 것이다. 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로 변경이 가능해야 한다. 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 한다. 모듈의 세 번째 목적은 코드를 읽는 사람과 의사소통하는 것이다. 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다. 읽는 사람과 의사소통할 수 없는 모듈은 개선해야 한다.[Martin02]
-   의존성(dependency):  
    의존성이라는 말 속에는 어떤 객체가 변경될 떄 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다. 그렇기 때문에 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고, 불필요한 의존성을 제거해야 한다.
-   결합도(coupling):  
    객체 사이의 의존성이 과한 경우를 가리킨다. 반대로 객체들이 합리적인 수준으로 의존할 경우에는 결합도가 낮다고 한다. 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이다.
-   캡슐화(encapsulation):  
    개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 말한다. 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다. 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다.
-   객체를 인터페이스(interface)와 구현(implementation)으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.
